-> Greedy
    -> given set that we can choose from ①
    -> while we can greedy selection, repeatedly to choose greedy ②
    -> return subset ③
        --> G=(V,E) ⊆ S, Dijkstra①
        --> while there are unknown vertex reachable from S, edge that introduces a new vertex with minimum coast ②
        --> return subset of edges that give you the subsetes path from s③
    -> interval scheduling (greedy)
        -> sort by earlier finish time
        -> maximum subsets --> see example and pic in other notes
            -> sort by finish time (earliest finsih time or latest start time)
            -> add to set if startTime(j) >= finishTime(last element in set)
            -> add startTime(j) to set and update last element in set to j(will automatically add)
            -> return set
        -> sorted by latest start time (maximum scheduling interval) sudocode from backwards  --> walk through the example
            -> time complexity O(nlogn) since sort, space complexity is O(1)
               sort by latest start time sn >= sn-1 >= sn-2---->=s2>=s1 or|| s1 >=s2 >=s3......>=sn
               s -> empty Si = 8
               for j = n -> 1 or||  1 -> n
                   if (job j compatible with s) means Si >= fj(sj is previous slot finish time)
                       add j to s, s <- s ∪ {j} what this means
                       // update current start time si to sj, si is current start time
                       Si = sj (8->4->1)
               return s
    -> earliest-finish-time-first-algorithms is optimal
        -> assume greedy is not optimal
        -> first one come after largest common prefix is different
        -> first one come after largest common prefix that greedy choose from finish earlier or equal to optimal time
        -> the one greedy choose must be compatible with Jm(the one after optimal difference)
        -> need to combine greedy and optimal subsolution (whatever is left in blue start from jm)is best
    -> find a counter example greedy gets into the way for sub problem, means greedy is not optimal solution
    -> if greedy is block/gets into the way to final the optimal solution is call optimal-sub-structure, so greedy is not optimal,, need to find a better soluction

* Dynamic problem
    -> scheduling interval with DP
    -> try compute this is DP at home
* Brute-Force example3
    -> find all sets
    -> say we start from 6, with compatibility considered, do not need to care p(4) and p(5)
    -> we introduce prior a wight its the stat time of jobn