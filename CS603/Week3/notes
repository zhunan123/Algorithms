* Counting Inversions
    -> How to compare each one's favorite movie rankings?
        -> use counting inversions, similar counting inversions will be pushed similar movie styles
        -> i & j are counting inversions if i < j but arr[i] > arr[j]
        -> example: [1, 3, 4, 2, 5]
            # 2 counting inversion 3-2, 4-2
        -> counting inversion is one application of merge sort
        -> the original is O(n^2) if we go thru every preference rankings, we don't want that, so we use divide and conquer, counting inversions
        -> divide and conquer
            # example [1, 4, 2, 3] -> [1, 4] & [2, 3] -> (so we grab right half to compare with left half)-> compare 2 with 1, bigger no inversion, but compre 2 with 4, 4 > 2 so found 1 inversion, then 4 also > 3 found another inversion
            # divide list into left half A and right half B
            # count inversions in A and count inversions in B -> 0 inversion in left and 0 inversion in right
            # compare left half and right half and count number if inversions (assume 2 halves list already sorted)
                ## will give inter-subarray counts of inversions between A abd B -> theres 2 inversions
            # return inversions in A + inversions in B + interSubArray inversions = final counting inversion
        -> another example: [1, 3, 5, 7] || [2, 4, 6, 8], starting with right half first 2 (which half found the smaller need to continue advance number to right)
            -> this example do not have List A inversions and List B inversions since it is already sorted, only have inversions between left array and right array
            -> start from right first and compare to left first (if left < right means no inversion found)
            -> 1 < 2, no inversion we just copy down 1 to temp arr and move left half pointer from 2 to 3
            -> compare 2 with second in first half 3 > 2,  so copy down 2 into temp arr, and move right side pointer from 2 to 4,  and we found 3 inversions since we know 3 is smallest,
                -> anything after 3 like 5 and 7 will also be greater than 2, so total 3 inversions
            -> than we grab next in right half 4 and compare to 3, 4 > 3 so no inversion, can bring 3 down to temp arr, and move left pointer from 3 to 5
            -> then compare 4 with 5, 5 > 4 so bring 4 down to temp arr, and we know 5 > 4 so found 1 inversions but every ele after 5 is greater  than 4 so totally 2 inversions, move right side pointer from 4 to 6
            -> compare 6 with 5, 5 < 6 so no inversion, copy 5 down and move 5 to 7, bring down 5
            -> compare 7 to 6, 7 > 6, 1 inversions found, bring 6 down, since 7 is last in left half, so total 1 inversion, move right side pointer from 6 to 8
            -> compare 7 to 8, 7 < 8, no inversion found, bring 7 down, done with left side
            -> bring 8 down
            -> then we added the inversion count this is only the inversions that we can found between left and right; total inversion count is 3 + 2 + 1 = 6
            -> this is called merge and count by adding up the inversions.
